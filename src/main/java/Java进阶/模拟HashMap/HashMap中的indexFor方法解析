
   static int indexFor(int h, int length) {
        return h & (length-1);
    }


1. 2^n转换成二进制就是1+n个0

 根据十进制的转化方式 : 十进制除以2取余数,然后商再除以2取余数,

 解析:

　　　因为2的n次方的数除以2总是余下0,当只剩下2的时候,商是1,最后1除以2余下1,

          从而2的n次方的数转化为二进制总是1+n个0


2. 2^n - 1转换成二进制总是n个1

   解析:

　　　2^n - 1的数除以2总是余下1,当只剩下2的时候,商是1,最后1除以2余下1,

          从而2的n次方的数转化为二进制总是n个1

3. 任意数只要和 n个1进行与运算,得出的结果一定会小于或等于n个1

   因为当这个数位数比n个1的位数长的时候,n个1前面,可以补上0, 任何数和0与运算都是0,

   然而任何数与1与运算都保持不变,从而得出的结果肯定会小于或等于n个1

4. 任何数与n个1进行与运算和取余运算符%是等价的

   根据第4点的结论,我们得知任意数只要和 n个1进行与运算,得出的结果一定会小于或等于n个1,

   任何%n==> 结果会小于或等于n,

   从而我们发现是等价的,这就能解释HashMap中的indexFor方法; 

   解析: 

     HashMap中的length总是2的n次方,而2的n次方减1总是n个1, 
   
     从而h & (length-1)等价于取余运算. 为什么要这么做呢? 

     因为&运算比%运算的效率高.

 

