
------------------------------------------------------------------------------------------------------------------

概念:

    什么是IO? (这里以硬盘举例,外部设备不仅仅是硬盘) 
       
       I 是从硬盘读取到内存,O是从内存输出到硬盘. 因为每读取一次硬盘耗时是比较长的,所以说IO操作时间比较长.
       正常情况下,输入输出流每读写一个字节就要操作硬盘一次,但是这样效率不高,耗时较长.所以才会设计缓存输入输出流,
       它们的优势就在于,当缓冲数组放满了之后,才读写一次硬盘,减少了IO次数,提高了效率. 

    注 : 当更高级的包装流关闭的时候 , 内部调用了底层的节点流 , 所有不需要重复去关闭.
-------------------------------------------------------------------------------------------------------------------


1.java io 操作详解参考 : https://www.cnblogs.com/ysocean/p/6864080.html

2.输入流  :  就是从磁盘中把文件读到程序来

3.输出流 : 就是把程序中的数据输出到磁盘中去,或者其他外部设备

4.什么叫外部设备内?
    相对于本电脑的内存而言,其他的存储介质都是外部设备.
    
  
5.操作 IO 流的模板流程

　　①、创建源或目标对象
　　　　输入：把文件中的数据流向到程序中，此时文件是 源，程序是目标
　　　　输出：把程序中的数据流向到文件中，此时文件是目标，程序是源

　　②、创建 IO 流对象
　　　　输入：创建输入流对象
　　　　输出：创建输出流对象

　　③、具体的 IO 操作

　　④、关闭资源
　　　　输入：输入流的 close() 方法
　　　　输出：输出流的 close() 方法

6.为什么要手动调用close关闭流?

  程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源。如果不关闭该资源，那么磁盘的文件将一直被程序引用着，不能删除也不能更改。所以应该手动调用 close() 方法关闭流资源

7.java io流的四大基流,其它流都是继承于这四大基流

  字节流 : InputStream  OutputStream

  字符流 : Reader Writer

8. 根据功能分为节点流和包装流

　　节点流 ：可以从或向一个特定的地方(节点)读写数据。如FileReader  FileInputStream ... (只要不是包装流,都是节点流,直接和文件对接的那个流)

　　包装 ：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。

           如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。  
 
 9.ByteArrayInputStream和ByteArrayOutputStream存在的意义是什么?

  1) ByteArrayInputStream在使用过程中没有IO操作，它存在的意义是将内存中的一个byte数组，
  
     让它可以通过InputStream的API来操作读取，主要是为了方便

     这两个流的作用在于：用IO流的方式来完成对字节数组的读写。

  2) 这两个类的实际用途

     什么是内存虚拟文件或者内存映像文件？

       他们是将一块内存虚拟成一个硬盘上的文件，原来该写到硬盘文件上的内容会被写到这个内存中，原来改从一个硬盘文件上读

取内容可以改为从内存中直接读取。

      （如果在程序运行过程中药产生过一些临时文件，就可以使用虚拟文件的方式来实现，不需要访问硬盘，而是直接访问内存）

       常见的应用：比如，我们的程序需要将一台计算机的屏幕图像通过网络不断地传送到另外的计算机上，为了节省网络带宽，我

们需要将一副屏幕图像进行压缩后，

       在通过网络发送出去。如果没有内存虚拟文件，我们需要将一台计算机的屏幕图像的像素数据写入到硬盘上的临时文件，再以

这个文件作为输入流对象去调用那个

       压缩函数，接着又从压缩函数生成的压缩文件中读取压缩后的数据，在通过网络发送出去，最后删除压缩前后生成的两个临时

文件。这个效率非常低。

       ByteArrayInputStream和ByteArrayOutputStream两个类可以实现类似内存虚拟文件的功能，我们将图像所有的像素数据保存

在一个数组中，然后根据数组创建一个

       ByteArrayInputStream流对象，同时创建一个用于保存压缩结果的ByteArrayOutputyStream流对象，将这两个对象作为参数传

递给压缩函数，最后从ByteArrayOutPutStream

       流对象中返回包含有压缩结果的数组


10.DataInputStream和DataOutputStream

   当我们要把一串有类型的基本数据发送到的时候,读取的时候希望按照原来的类型读取出来.
 
   其实完全可以发送一段json过去,自己去解析.没必要那么麻烦.

   它和普通的流的区别就在于可以发送任意基本类型的数据,对面接收的时候也可以直接转化过来.相对于

   字符流只能发送字符,字节流只能发送字节来说,还有扩展了一点功能. 

   唯一恶心的就是要按写入的顺序读取.

   (很多时候我们并不想传一个一个的数据,而是想传一整个对象,这个时候就要去ObjectInputStream找答案了)

11.PushbakInputStream
  
    PushbakInputStream类在初始化的时候声明的一个1字节的数组buf,当然也可以在构造的时候指定长度.pos初始的时候等于

buf.length,

    当我们往这个数组里面unread(b[] b) 的时候,如果b比buf小,则b数组会被拷贝到buf的尾部,每次读取read(c[] c) 总会

    先把buf中尾部的那块内容先拷贝c的前面.然后pos恢复为buf.length. 说白了,就是定义一个缓冲区供你存放临时的字节数组,

    再读取的时候每次把这个字节带上.

    应用场景 :
  
       可以试探性地读取一个字节，看是否符合要求，然后再回退回去一个字节后，再读取字节。 (这种场合还没有)
       
       我的想法  : 如果我想在不关闭流的情况下返回读取某个文件,我可以把缓冲区设置为文件大小,读完我全部弹回去,然后继续读.

                         (其实和用ByteArrayOutputStream输出到内存中做的效果是一样的,该类还是用于试探性读取是最好的场合,

                         这样会比全部读取再去判断的效率更高)

12.PrintStream

   System是一个对象,而out是System的一个属性,类型就是PrintStream,
  

13.ObjectInputStream 和 ObjectOutStream

    ObjectInputStream和ObjectOutStream是专门对于对象读写的，要求类已经实现了Serializable接口.

    应用场景 : 在远程调用接口中,可以通过这两个类来传输对象,非常有用
   
    参考 : http://blog.csdn.net/chybin500/article/details/78706546

14.PipedInputStream和PipedOutStream

  PipedOutputStream和PipedInputStream是管道输出流和管道输入流，配合使用可以实现线程间通信.

  注 : 单词piped就是管道的意思 , 两个流通过方法connect对接起来,例如 : pos.connect(pis);

15.SequenceInputStream

   合并流：把多个输入流合并为一个流，也叫顺序流，因为在读取的时候是先读第一个，读完了在读下面一个流。
   
   应用场景:

     我们可以把多个小文件合并成一个大文件

16.StringBufferInputStream
      
   这个是String使用输入流来读取,其实和数组流差不多,但是这个流已经过时,推荐使用StringReader

   读出来的东西也乱码,而用StringReader就不会有乱码
           
    
   