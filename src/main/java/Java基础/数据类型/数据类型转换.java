package Java基础.数据类型;

public class 数据类型转换 {
	public static void main(String[] args) {
		//自动转换
		byte a=123; //不超过范围,整型数值可以直接转byte
		//byte a1=129;//整型数值超过byte的范围,报错
		int a1='a'; //字符可以直接转int,字符的表示范围"0-65536"在int的表示范围内,可以直接转
		char  a2=97;  //整型常量只要在char的范围内就可以直接转
		long a3=12332;
		float b=a3;  //long和float都是4个字节,但是long的表示范围在float的范围内,所以可以直接转
	
		
		//强制转型
		int c=100;
		/*
		 	c是一个整型变量,c的整型的表示范围超过了char的表示范围,从而要强转;
		  	如果c的值超过了char的表示范围,则会损失精度
		 */
		char d=(char)c; 
		int c1=132412341;
		char d1=(char)c1; //c1超过了d1的表示范围,已经损失了精度,字符打印出来一个"玵"字;
		int c2=d1;
		System.out.println("d="+d+" d1="+d1);
		System.out.println("损失精度后的c2的值:"+c2);
		
		//类型提升问题(不同类型的数据进行算数运算的时候,计算结果值的类型是表示范围最大的那个类型)
		int e=10;
		long e1=20;
		//当int和long类型进行相加时,得到的值自动提升为范围比较大的long类型,从而赋值给e2要强转
		int e2=(int) (e+e1); 
		double e3=3123.2;
		int e4=(int)(e+e1+e3);
		System.out.println("e2="+e2+" e4="+e4);
		
		//同一类型的数据进行算数运算,运算结果依然是该类型;
		int f=1000000000;
		int f1=200;
		//整型与整型运算依然是整型,但是计算结果超过了表示范围,值变成了负数-1863462912
		System.out.println(f*f1);
		//f*f1值在long的表示范围内,从而我们得先把f转成long,计算结果会自动提升为long类型,从而得到正确结果
		System.out.println((long)f*f1);
		
		//计算一个70岁的人一生的心跳
		long g=70*60*24*365*70; //70*60*24*365*70,这些常量都是int,从而结果的类型是int,从而会溢出
		System.out.println(g); //溢出了
		//正确的写法
		long g1=70L*60*24*365*70; //把第一个70转为long,那结果就是long类型了
		System.out.println(g1);
		
		/*
			--数据类型转换
		    1) 容量小的数据类型可以自动转换为容量大的数据类型
		    2) 可以将整型常量直接赋值给byte,short,char等类型变量,而不需要进行强制类型转换,只要不超过其表数范围
		    3) 强类型转换:
		             a) 又被称为造型,用于显示的转换一个数值的类型,在有可能丢失信息的情况下进行的转换是通过造型来完成的,
		                 但可能造成精度降低或移除.
		             b) 当将一种类型强制转换成另一种类型,而又超出了目标类型的表示范围,就会被截断成为一个完全不同的值.
		    4) 类型提升问题
		       不同类型的数据进行算数运算的时候,计算结果值的类型是表示范围最大的那个类型
		    注意:
		        1) 同一种类型进行算数运算,计算的结果依然是该类型.
		        2) 操作比较大的值时,要注意是否会溢出,尤其是整数操作
	    */
	}
}
