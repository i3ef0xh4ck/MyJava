参考 : https://www.jianshu.com/p/25e243850bd2?appinstall=0

1.锁池和等待池是什么?
  
  1) 每个锁内部会维护两个集合,一个称之为锁池,一个称之为等待池.锁池和等待池记录的是线程的id.
  
  2) 锁池
  
	  当有多个线程竞争一个锁的时候,只有一个线程竞争到了锁,其它线程讲进入锁池里面.锁池里面的线程,
	  
	  当有线程释放锁的时候,将会唤醒锁池里面的一个线程,该线程会参与到竞争锁当中去,如果竞争不到,则
	  
	  回到锁池中.
  
  3) 等待池
  
      当有一个线程竞争到了锁的时候,如果在临界区调用wait方法,则该线程会先释放锁,然后变成等待状态.
  
      该线程会进入到等待池中,当锁调用notify方法的时候,该线程会被唤醒,然后参与到竞争锁的过程中,如果
     
      竞争不到,该线程会进入到锁池中.
      
2.为什么wait方法一定要放到while循环中呢?

   举例说明,在生产者和消费者的案例中,消费则发现数组里没有元素的时候,就会进入等待状态.当被别的线程唤醒的时候,
   
   会继续往下执行,而下面的操作的是获取元素,并移除该元素.如果是被其它的消费者线程唤醒并竞争到了锁,此时的数组依然为空,这个时候
   
   继续往下执行就会报空指针异常.所以被唤醒的时候依然要去检查一下条件,如果不符合条件继续调用wait方法,如果符合才往下运行.
   
 3.为什么要使用notifyAll而不应该使用notify呢?
 
   因为只要调用wait方法,线程都会进入到等待池中.等待池中即包含消费者线程,也包含生产者线程.如果此时此刻等待池中有1个生产者线程,
   
   1个消费者进行,另外一个消费者消费完进行notify()唤醒的是消费者,则消费者发现没有元素则继续等待.而生产者也在等待,导致无法继续进行下去,
   
   这就是死锁现象.如果用notifyAll的话,则锁池的所有线程都会进入到锁池中,去竞争锁,所有不会发生死锁现象.
   
   其实就是notify可能造成线程一直在等待状态,没人去竞争锁,也就造成了没人生产或没人消费的情况.而notifyAll能
   
   确保有人去竞争锁,而且确认能有一个人生产或者消费,从而继续运行下去.
      

  
  
     